{"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"abstract":[{"type":"text","text":"Moving from 1.x to 2.0"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"paths":["\/documentation\/factory\/migration"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"article","sections":[],"metadata":{"modules":[{"name":"Factory"}],"role":"article","roleHeading":"Article","title":"Migration"},"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Migration","interfaceLanguage":"swift"},"primaryContentSections":[{"kind":"content","content":[{"text":"Overview","level":2,"type":"heading","anchor":"Overview"},{"inlineContent":[{"type":"text","text":"Factory 2.0 is planning for the future, and as such it needs to break from the past."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Containers in Factory 1.X were essentially namespaces, and not actual object instances that could be passed around. That made the overall syntax slightly cleaner, but the tradeoff resulted in a lack of functionality and the static class definitions prevented Factory from being used in anything other than a Service Locator role."}],"type":"paragraph"},{"inlineContent":[{"text":"That wasn’t good.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So that changed in Factory 2.0. Instead of defining Factory’s as static variables on a class, they’re now defined and returned as computed variables on the container itself. And instances of a given container can be created and shared as needed."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Let’s take a look.","type":"text"}]},{"type":"heading","anchor":"Defining-a-Factory","level":2,"text":"Defining a Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define that a given dependency is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}]},{"type":"paragraph","inlineContent":[{"text":"Factory, as you may have guessed from the name, is no exception. Here’s a simple registration that returns a ","type":"text"},{"code":"ServiceType","type":"codeVoice"},{"type":"text","text":" dependency."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        self { MyService() }","    }","}"]},{"inlineContent":[{"text":"We extended a Factory ","type":"text"},{"code":"Container","type":"codeVoice"},{"type":"text","text":" and within that container we defined a new computed variable of type "},{"code":"Factory<ServiceType>","type":"codeVoice"},{"type":"text","text":". The type must be explicitly defined, and is usually a"},{"type":"text","text":" "},{"text":"protocol to which the returned dependency conforms.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"So our computed variable needs to return a Factory. But Factory’s are complex creatures. They need to communicate with their enclosing containers and they need to be provided with a closure that can be called to create an instance of our dependency when required.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As such, a complete, formal Factory definition would look like this…"}]},{"type":"codeListing","syntax":"swift","code":["var service: Factory<ServiceType> {","    Factory(self, scope: .unique) { ","        MyService()","    }","}"]},{"inlineContent":[{"type":"text","text":"But we can do better. Factory provides a bit of syntactic sugar that asks the enclosing container to make our factory for us."}],"type":"paragraph"},{"code":["var service: Factory<ServiceType> {","    self { MyService() }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"That Factory is then returned to the caller, usually to be evaluated (see "},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()","isActive":true,"type":"reference"},{"text":"). Every time we resolve this factory we’ll get a new, unique instance of our object.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Just for reference, here’s are the Factory 1.x and 2.0 registration definitions side by side."}],"type":"paragraph"},{"code":["extension Container {","    \/\/ Factory 1.x","    static var service = Factory<ServiceType> { MyService() }","    ","    \/\/ Factory 2.0","    var service: Factory<ServiceType> { self { MyService() } }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The new version is one character longer. Hey. I tried… ;)"}]},{"inlineContent":[{"text":"Like SwiftUI Views, Factory structs and modifiers are lightweight and transitory. In Factory 2.0 they’re created when needed and then immediately discarded once their purpose has been served.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"See the ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers"},{"text":" page for a lot more on the subject.","type":"text"}],"type":"paragraph"},{"text":"Resolving a Factory","type":"heading","level":2,"anchor":"Resolving-a-Factory"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To resolve a Factory and obtain an object or service of the desired type, one simply calls the Factory as a function. If you’re passing an instance of a container around to your views or view models, just call it directly."}]},{"code":["let service = container.service()"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The resolved instance may be brand new or Factory may return a cached value from the specified ","type":"text"},{"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"We can also use the ","type":"text"},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container that’s provided for each and every container type."}]},{"syntax":"swift","code":["let service = Container.shared.service()"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note that this is fundamentally the same as the Service Locator pattern used in Factory 1.0."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ Factory 1.0 resolution","let service = Container.service()"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, you can also use the @Injected property wrapper. That’s changed too, and now uses keyPaths to indicate the desired dependency."}]},{"type":"codeListing","code":["@Injected(\\.service) var service: ServiceType"],"syntax":"swift"},{"inlineContent":[{"text":"The @Injected property wrapper looks for dependencies in the shared container, so this example is functionally identical to the ","type":"text"},{"type":"codeVoice","code":"Container.shared.service()"},{"type":"text","text":" version shown above."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected"},{"type":"text","text":", "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected"},{"type":"text","text":", and "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/InjectedObject"},{"type":"text","text":" for more."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Factory 1.0 version for reference","@Injected(Container.service) var service: ServiceType"]},{"level":2,"text":"Registering a new Factory closure","anchor":"Registering-a-new-Factory-closure","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"What happens if we want to change the behavior of a Factory? What if the system changes during runtime, or what if we want our factory to provide mocks and testing doubles?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s easy, and works pretty much the same as it did before. Just register a new closure with the Factory from its container."}]},{"syntax":"swift","type":"codeListing","code":["container.service.register {","    MockService()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new factory closure overrides the original factory closure and clears the associated scope so that the next time this factory is resolved Factory will evaluate the new closure and return an instance of the newly registered object instead."}]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Warning"}]},{"text":": Registration “overrides” and scope caches are stored in the associated container. If the container ever goes out of scope, so will all of its registrations.","type":"text"}]}],"style":"note","name":"Note"},{"inlineContent":[{"type":"text","text":"Again, see the "},{"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","isActive":true},{"text":" page for a lot more on the subject.","type":"text"}],"type":"paragraph"},{"level":2,"type":"heading","anchor":"Scopes","text":"Scopes"},{"inlineContent":[{"text":"Scopes behave exactly as they did before, although they’re now defined using a modifier syntax on the Factory.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var singletonService: Factory<ServiceType> {","        self { MyService() }.singleton","    }","    var decoratedSharedService: Factory<MyServiceType> {","        self { MyService() }","            .shared","            .decorator { print(\"DECORATING \\($0.id)\") }","    }","}"]},{"inlineContent":[{"type":"text","text":"Factory 2.0 also provides additional modifiers for all of the known scopes, as well as a few more like the per-factory decorator shown above."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Resetting","text":"Resetting"},{"inlineContent":[{"type":"text","text":"When doing tests and in other situations it was relatively common to reset factories and factory scopes and we can still do that today. Again, it’s just the syntax that’s a little different."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just keep in mind that in Factory 1.0 registrations and scopes were global, whereas today we ask our container to do the job for us."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Reset everything based in that container.","Container.shared.manager.reset()","","\/\/ Reset all registrations, restoring original factories but leaving caches intact","Container.shared.manager.reset(options: .registration)","","\/\/ Reset all scope caches, leaving registrations intact","Container.shared.manager.reset(options: .scope)"]},{"inlineContent":[{"type":"text","text":"You can also reset a specific scope cache while leaving the others intact."}],"type":"paragraph"},{"type":"codeListing","code":["Container.shared.manager.reset(scope: .cached)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Resetting a container only affects that container.","type":"text"}]},{"text":"Creating Custom Containers and Scopes","type":"heading","level":2,"anchor":"Creating-Custom-Containers-and-Scopes"},{"type":"paragraph","inlineContent":[{"text":"Again, a bit different. Rather than duplicate the documentation for doing so, please checkout the appropriate section in the ","type":"text"},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","type":"reference","isActive":true},{"type":"text","text":" or "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes"},{"text":" documentation.","type":"text"}]}]}],"references":{"doc://Factory/documentation/Factory/Scope":{"abstract":[{"type":"text","text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,"},{"text":" ","type":"text"},{"text":"including ","type":"text"},{"code":"Singleton","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Cached","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Graph"},{"text":", and ","type":"text"},{"code":"Shared","type":"codeVoice"},{"type":"text","text":"."}],"kind":"symbol","title":"Scope","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scope","type":"topic","navigatorTitle":[{"text":"Scope","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Scope"}],"url":"\/documentation\/factory\/scope","role":"symbol"},"doc://Factory/documentation/Factory/Injected":{"type":"topic","kind":"symbol","role":"symbol","url":"\/documentation\/factory\/injected","navigatorTitle":[{"kind":"identifier","text":"Injected"}],"title":"Injected","identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected","abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Injected","kind":"identifier"}]},"doc://Factory/documentation/Factory":{"kind":"symbol","title":"Factory","identifier":"doc:\/\/Factory\/documentation\/Factory","url":"\/documentation\/factory","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"role":"collection","type":"topic"},"doc://Factory/documentation/Factory/LazyInjected":{"type":"topic","navigatorTitle":[{"text":"LazyInjected","kind":"identifier"}],"kind":"symbol","title":"LazyInjected","abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type the first time the wrapped value is requested.","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected","url":"\/documentation\/factory\/lazyinjected","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"LazyInjected"}]},"doc://Factory/documentation/Factory/Containers":{"kind":"article","abstract":[{"text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Containers","title":"Containers","type":"topic","url":"\/documentation\/factory\/containers","role":"article"},"doc://Factory/documentation/Factory/InjectedObject":{"kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"InjectedObject"}],"navigatorTitle":[{"text":"InjectedObject","kind":"identifier"}],"url":"\/documentation\/factory\/injectedobject","abstract":[{"text":"Immediate injection property wrapper for SwiftUI ObservableObjects.","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/InjectedObject","role":"symbol","title":"InjectedObject"},"doc://Factory/documentation/Factory/Factory/callAsFunction()":{"abstract":[{"type":"text","text":"Evaluates the factory and returns an object or service of the desired type. The resolved instance may be brand new or Factory may"},{"text":" ","type":"text"},{"text":"return a cached value from the specified scope.","type":"text"}],"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"callAsFunction","kind":"identifier"},{"kind":"text","text":"() -> "},{"text":"T","kind":"typeIdentifier"}],"type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Factory\/callAsFunction()","title":"callAsFunction()","url":"\/documentation\/factory\/factory\/callasfunction()","role":"symbol","kind":"symbol"},"doc://Factory/documentation/Factory/Scopes":{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","type":"topic","title":"Scopes","abstract":[{"text":"Not everything wants to be a Singleton. Learn the power of Scopes.","type":"text"}],"url":"\/documentation\/factory\/scopes","kind":"article","role":"collectionGroup"},"doc://Factory/documentation/Factory/WeakLazyInjected":{"type":"topic","kind":"symbol","role":"symbol","url":"\/documentation\/factory\/weaklazyinjected","navigatorTitle":[{"kind":"identifier","text":"WeakLazyInjected"}],"title":"WeakLazyInjected","identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected","abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves a weak instance of the desired type the first time the wrapped value is requested."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"WeakLazyInjected"}]}}}