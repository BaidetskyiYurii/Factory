{"abstract":[{"type":"text","text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?"}],"sections":[],"seeAlsoSections":[{"identifiers":["doc:\/\/Factory\/documentation\/Factory\/GettingStarted","doc:\/\/Factory\/documentation\/Factory\/Scopes"],"generated":true,"title":"The Basics"}],"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"Containers are used by Factory to manage object creation, object resolution, and object lifecycles in general.","type":"text"}]},{"inlineContent":[{"text":"In Factory 1.0 with its statically defined Factory’s a “container” was really just a convenient namespace. But in Factory 2.0 a container is a distinct object that can be referenced, passed around, and deallocated as needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can even create separate instances of the same container type, each with its own registrations and scope caches.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Factory 2.0 supports true container-based dependency injection."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Containers-and-Factories","text":"Containers and Factories"},{"inlineContent":[{"type":"text","text":"A Factory definition is a computed property defined within a container extension. Each Factory needs a reference to its container, a scope, and it also requires a factory closure that will produce our dependency when asked to do so."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s a lot of code, so we usually just ask the enclosing container to make our Factory for us…"}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    var service: Factory<MyServiceType> {","        self { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This process is covered in greater detail in ","type":"text"},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","type":"reference","isActive":true},{"type":"text","text":"."}]},{"text":"Resolving a Dependency","anchor":"Resolving-a-Dependency","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Once you’ve added a Factory to a container you can resolve it."}],"type":"paragraph"},{"code":["let service = Container.shared.service()"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Bingo. You now have your dependency.","type":"text"}]},{"type":"heading","level":2,"text":"The Default Container","anchor":"The-Default-Container"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory ships with a single "},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container","isActive":true,"type":"reference"},{"text":" already constructed for your convenience.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["public final class Container: SharedContainer {","    public static let shared = MyContainer()","    public let manager = ContainerManager()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You’ve seen it used and extended in all of the examples we’ve seen thus far, and most projects can simply extend it and go."}]},{"anchor":"Containershared","level":2,"text":"Container.shared","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As the default Container definition shows, each container class defined has a statically allocated "},{"code":"shared","type":"codeVoice"},{"type":"text","text":" instance associated with it."}]},{"type":"paragraph","inlineContent":[{"text":"This instance can be referenced directly if you’re using a Service Locator-style pattern.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let service = Container.shared.service()"]},{"type":"paragraph","inlineContent":[{"text":"Or you can use the “shared” container as an application root container and pass it along to wherever it’s needed. Let’s take a look.","type":"text"}]},{"type":"heading","anchor":"Passing-Containers","level":2,"text":"Passing Containers"},{"inlineContent":[{"type":"text","text":"Here’s an example of passing an instance of a container to a view model and then initializing a service from that container."}],"type":"paragraph"},{"syntax":"swift","code":["class ContentViewModel {","    let service2: MyServiceType","    init(container: Container) {","        service2 = container.service()","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Additional examples and methods can be seen on the "},{"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","isActive":true},{"type":"text","text":" page."}],"type":"paragraph"},{"type":"heading","text":"SharedContainer","anchor":"SharedContainer","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"All containers conform to the "},{"code":"SharedContainer","type":"codeVoice"},{"type":"text","text":" protocol. That basically means that each one must have its own "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager"},{"text":" and implement a static ","type":"text"},{"type":"codeVoice","code":"shared"},{"text":" instance.","type":"text"}]},{"inlineContent":[{"type":"text","text":"SharedContainer also defines some common functionality for each container, like the "},{"code":"unique","type":"codeVoice"},{"text":" convenience function we’ve seen used throughout.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Note that you can extend SharedContainer with your own Factory’s.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension SharedContainer {","    var commonService: Factory<ServiceType> {","        self { MyService() }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"commonService"},{"type":"text","text":" Factory will now be available on every container created."}]},{"syntax":"swift","type":"codeListing","code":["let common1 = Container.shared.commonService()","let common2 = MyContainer.shared.commonService()"]},{"anchor":"Custom-Containers","text":"Custom Containers","type":"heading","level":2},{"inlineContent":[{"text":"In a large project you might want to segregate factories into additional, smaller containers.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Defining your own container class is simple. Just use the following as a template."}],"type":"paragraph"},{"syntax":"swift","code":["public final class MyContainer: SharedContainer {","     public static let shared = MyContainer()","     public let manager = ContainerManager()","}","","extension MyContainer {","    var cachedService: Factory<ServiceType> {","        self { MyService() }.cached","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"As mentioned, a container must derive from "},{"type":"codeVoice","code":"SharedContainer"},{"type":"text","text":", have its own "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager"},{"type":"text","text":", and implement a static "},{"type":"codeVoice","code":"shared"},{"type":"text","text":" instance. It also must be marked "},{"type":"codeVoice","code":"final"},{"text":".","type":"text"}],"type":"paragraph"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"Remember to define the “shared” container as a ","type":"text"},{"type":"codeVoice","code":"let"},{"type":"text","text":", not "},{"code":"var","type":"codeVoice"},{"type":"text","text":". Defining it as a "},{"type":"codeVoice","code":"static var"},{"text":" will cause Swift to issue concurrency warnings in the future whenever that variable is accessed.","type":"text"}]}],"name":"Note"},{"text":"Referencing Other Containers","type":"heading","anchor":"Referencing-Other-Containers","level":2},{"type":"paragraph","inlineContent":[{"text":"Don’t forget that if need be you can reach across containers simply by specifying the full ","type":"text"},{"type":"codeVoice","code":"container.factory"},{"text":" path.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension PaymentsContainer {","    let anotherService = Factory<AnotherService> { ","        self { AnotherService(using: Container.shared.optionalService()) }","    }","}"]},{"text":"Injected Property Wrappers","anchor":"Injected-Property-Wrappers","level":2,"type":"heading"},{"inlineContent":[{"text":"Property wrappers like ","type":"text"},{"type":"codeVoice","code":"@Injected"},{"type":"text","text":" and "},{"code":"@LazyInjected","type":"codeVoice"},{"text":" always reference the ","type":"text"},{"type":"codeVoice","code":"shared"},{"type":"text","text":" container for that class type. Let’s get an instance of the "},{"code":"cachedService","type":"codeVoice"},{"type":"text","text":" object we defined above by providing a keypath to the desired class and service."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["class ContentViewModel: ObservableObject {","    @Injected(\\MyContainer.cachedService) var cachedService","}"]},{"inlineContent":[{"type":"text","text":"We now have an instance of "},{"type":"codeVoice","code":"cachedService"},{"text":" in our view model, as well as a reference to the same instance cached in ","type":"text"},{"code":"MyContainer.shared.manager","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"See "},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected","isActive":true,"type":"reference"},{"type":"text","text":", "},{"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected","isActive":true},{"type":"text","text":", "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected"},{"type":"text","text":", and "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/InjectedObject"},{"text":" for more.","type":"text"}]},{"type":"heading","text":"Registration and Scope Management","level":2,"anchor":"Registration-and-Scope-Management"},{"inlineContent":[{"text":"As mentioned earlier, factory registrations and scopes are managed by the container on which the dependency was created. Adding a registration or clearing a scope cache on one container has no effect on any other container.","type":"text"}],"type":"paragraph"},{"code":["let containerA = MyContainer()","containerA.register.cachedService { MockService() }","","\/\/ Will have a MockService","let service1 = containerA.cachedService() ","","\/\/ Will have a new or previously cached instance of ServiceType","let service2 = MyContainer.shared.cachedService() "],"type":"codeListing","syntax":"swift"},{"text":"AutoRegister","type":"heading","level":2,"anchor":"AutoRegister"},{"type":"paragraph","inlineContent":[{"type":"text","text":"From time to time you may find that you need to register or change some instances prior to application initialization. If so you can do the following."}]},{"code":["extension MyContainer: AutoRegistering {","    func autoRegister() {","        someService.register { ModuleB.SomeService() }","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Just make your container conform to "},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/AutoRegistering"},{"type":"text","text":" and provide the "},{"type":"codeVoice","code":"autoRegister"},{"text":" function. This function will be called ","type":"text"},{"inlineContent":[{"type":"text","text":"once"}],"type":"emphasis"},{"text":" prior to the very first Factory service resolution on that container.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that this can come in handy when you want to register instances of objects obtained across different modules, or change settings in the container manager."}],"type":"paragraph"},{"type":"heading","text":"AutoRegister and the Default Container","anchor":"AutoRegister-and-the-Default-Container","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"One can add auto registration capabilities to Factory’s default container as well, but as of Swift 6 you’ll need to add the "},{"code":"@retroactive","type":"codeVoice"},{"text":"","type":"text"},{"type":"text","text":" "},{"type":"text","text":"attribute to the "},{"code":"AutoRegistering","type":"codeVoice"},{"type":"text","text":" protocol definition."}]},{"code":["extension Container: @retroactive AutoRegistering {","    func autoRegister() {","        someService.register { ModuleB.SomeService() }","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This new attribute silences the warning, “Extension declares a conformance of imported type ‘Container’ to imported protocol ‘AutoRegistering’;"},{"text":" ","type":"text"},{"type":"text","text":"this will not behave correctly if the owners of ‘Factory’ introduce this conformance in the future”."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Yeah. Me too. I know the developers of Swift mean well, but sometimes…","type":"text"}]},{"type":"heading","level":2,"text":"Resetting a Container","anchor":"Resetting-a-Container"},{"type":"paragraph","inlineContent":[{"text":"Using ","type":"text"},{"code":"register","type":"codeVoice"},{"text":" on a factory lets us change the state of the system. But what if we need to revert to the original behavior?","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Simple. Just reset it to bring back the original factory closure. Or, if desired, you can reset ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"everything","type":"text"}]},{"text":" back to square one with a single command.","type":"text"}]},{"syntax":"Swift","code":["container.myService.reset() \/\/ resets this factory only","container.manager.reset() \/\/ clears all registrations and caches","container.reset() \/\/ shortcut, same as above"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also reset registrations and scope caches specifically, leaving the other intact."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Reset all registrations, restoring original factories but leaving caches intact","Container.shared.manager.reset(options: .registration)","","\/\/ Reset all scope caches, leaving registrations intact","Container.shared.manager.reset(options: .scope)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also reset a specific scope cache while leaving the others intact."}]},{"type":"codeListing","code":["Container.shared.manager.reset(scope: .cached)"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Note that resetting registrations also resets the container’s auto registration flag.","type":"text"}]},{"style":"important","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Resetting a container or scope has no effect whatsoever on anything that’s already been resolved by Factory. It only ensures that the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"next"}]},{"type":"text","text":" time a Factory is asked to resolve a dependency that dependency will be a new instance."}]}],"name":"Important"},{"text":"Pushing and Popping State","anchor":"Pushing-and-Popping-State","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"As with Factory 1.0, the state of a container’s registrations and scope caches can be saved (pushed), and then restored (popped). See "},{"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","isActive":true},{"type":"text","text":" for more information on this."}],"type":"paragraph"},{"level":2,"anchor":"Releasing-a-Container","text":"Releasing a Container","type":"heading"},{"style":"warning","content":[{"inlineContent":[{"type":"text","text":"If a container ever goes out of scope, so will all of its registrations and cached objects."}],"type":"paragraph"}],"type":"aside","name":"Warning"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To demonstrate, let’s see what happens when we create and then reassign a new container. Doing so releases the previous container, along with any registrations or objects that container may have cached. We’ll use the "},{"type":"codeVoice","code":"cachedService"},{"type":"text","text":" Factory we defined above."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create an instance of our cached service.","var container = MyContainer()","let service1 = container.cachedService()","","\/\/ Repeat, which returns the same cached instance we obtained in service1.","let service2 = container.cachedService()","assert(service1.id == service2.id)","","\/\/ Replace the existing shared container with a new one.","container = MyContainer()","","\/\/ Trying again gets a new instance since the old container and cache was released.","let service3 = container.cachedService()","assert(service1.id != service3.id)","","\/\/ Repeat and receive the same cached instance we obtained in service3.","let service4 = container.cachedService()","assert(service3.id == service4.id)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"From a certain point of view, replacing a container with a new one is the ultimate reset mechanism."}]},{"type":"aside","name":"Note","content":[{"inlineContent":[{"type":"text","text":"As of Factory 2.2 it’s no longer possible to reassign the default “shared” container. This change clears several warnings that could be issued by Swift concurrency when “complete” checking is enabled and one attempts to access the container via the shared static variable (e.g. "},{"type":"codeVoice","code":"let s = Container.shared.myService()"},{"text":").","type":"text"}],"type":"paragraph"}],"style":"note"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/factory\/containers"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"title":"Containers","roleHeading":"Article","modules":[{"name":"Factory"}],"role":"article"},"kind":"article","identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Containers","interfaceLanguage":"swift"},"references":{"doc://Factory/documentation/Factory/Injected":{"navigatorTitle":[{"text":"Injected","kind":"identifier"}],"url":"\/documentation\/factory\/injected","abstract":[{"text":"Convenience property wrapper takes a factory and resolves an instance of the desired type.","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Injected","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Injected","kind":"identifier"}],"title":"Injected","type":"topic","kind":"symbol","role":"symbol"},"doc://Factory/documentation/Factory/ContainerManager":{"identifier":"doc:\/\/Factory\/documentation\/Factory\/ContainerManager","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"ContainerManager","kind":"identifier"}],"type":"topic","title":"ContainerManager","url":"\/documentation\/factory\/containermanager","abstract":[{"text":"ContainerManager manages the registration and scope caching storage mechanisms for a given container.","type":"text"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContainerManager","kind":"identifier"}]},"doc://Factory/documentation/Factory/Testing":{"role":"article","abstract":[{"text":"Using Factory for Unit and UI Testing.","type":"text"}],"title":"Testing","type":"topic","url":"\/documentation\/factory\/testing","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing","kind":"article"},"doc://Factory/documentation/Factory/GettingStarted":{"role":"collectionGroup","abstract":[{"type":"text","text":"Defining a Factory, resolving it, and changing the default behavior."}],"title":"Getting Started","type":"topic","url":"\/documentation\/factory\/gettingstarted","identifier":"doc:\/\/Factory\/documentation\/Factory\/GettingStarted","kind":"article"},"doc://Factory/documentation/Factory/Resolutions":{"type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Resolutions","kind":"article","role":"article","title":"Sample Resolutions","abstract":[{"text":"There are many ways to use Factory to resolve dependencies. Here are a few examples.","type":"text"}],"url":"\/documentation\/factory\/resolutions"},"doc://Factory/documentation/Factory/LazyInjected":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LazyInjected","kind":"identifier"}],"abstract":[{"type":"text","text":"Convenience property wrapper takes a factory and resolves an instance of the desired type the first time the wrapped value is requested."}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/LazyInjected","role":"symbol","title":"LazyInjected","kind":"symbol","url":"\/documentation\/factory\/lazyinjected","type":"topic","navigatorTitle":[{"kind":"identifier","text":"LazyInjected"}]},"doc://Factory/documentation/Factory/Scopes":{"role":"collectionGroup","url":"\/documentation\/factory\/scopes","identifier":"doc:\/\/Factory\/documentation\/Factory\/Scopes","abstract":[{"text":"Not everything wants to be a Singleton. Learn the power of Scopes.","type":"text"}],"kind":"article","title":"Scopes","type":"topic"},"doc://Factory/documentation/Factory/InjectedObject":{"abstract":[{"type":"text","text":"Immediate injection property wrapper for SwiftUI ObservableObjects."}],"kind":"symbol","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"InjectedObject","kind":"identifier"}],"navigatorTitle":[{"text":"InjectedObject","kind":"identifier"}],"url":"\/documentation\/factory\/injectedobject","type":"topic","title":"InjectedObject","identifier":"doc:\/\/Factory\/documentation\/Factory\/InjectedObject"},"doc://Factory/documentation/Factory/AutoRegistering":{"navigatorTitle":[{"text":"AutoRegistering","kind":"identifier"}],"type":"topic","abstract":[{"text":"Adds an registration “hook” to a ","type":"text"},{"code":"Container","type":"codeVoice"},{"text":".","type":"text"}],"kind":"symbol","url":"\/documentation\/factory\/autoregistering","role":"symbol","identifier":"doc:\/\/Factory\/documentation\/Factory\/AutoRegistering","title":"AutoRegistering","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AutoRegistering","kind":"identifier"}]},"doc://Factory/documentation/Factory":{"role":"collection","type":"topic","abstract":[{"text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory","url":"\/documentation\/factory","title":"Factory","kind":"symbol"},"doc://Factory/documentation/Factory/WeakLazyInjected":{"url":"\/documentation\/factory\/weaklazyinjected","kind":"symbol","role":"symbol","identifier":"doc:\/\/Factory\/documentation\/Factory\/WeakLazyInjected","type":"topic","abstract":[{"text":"Convenience property wrapper takes a factory and resolves a weak instance of the desired type the first time the wrapped value is requested.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"WeakLazyInjected"}],"title":"WeakLazyInjected","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"WeakLazyInjected","kind":"identifier"}]},"doc://Factory/documentation/Factory/Container":{"url":"\/documentation\/factory\/container","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"Container","kind":"identifier"}],"identifier":"doc:\/\/Factory\/documentation\/Factory\/Container","abstract":[{"type":"text","text":"This is the default Container provided for your convenience by Factory."}],"navigatorTitle":[{"kind":"identifier","text":"Container"}],"title":"Container","kind":"symbol","type":"topic","role":"symbol"}}}