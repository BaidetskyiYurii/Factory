{"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"seeAlsoSections":[{"identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Contexts","doc:\/\/Factory\/documentation\/Factory\/Debugging","doc:\/\/Factory\/documentation\/Factory\/Chains"],"generated":true,"title":"Development and Testing"}],"schemaVersion":{"major":0,"patch":0,"minor":3},"identifier":{"url":"doc:\/\/Factory\/documentation\/Factory\/Testing","interfaceLanguage":"swift"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factory\/testing"]}],"primaryContentSections":[{"content":[{"anchor":"Overview","type":"heading","level":2,"text":"Overview"},{"inlineContent":[{"text":"Dependency injection exists to manage and decouple dependencies among objects; making the code more modular, maintainable, and testable. It says so right on the label.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"As you’ve already seen, the main mechanism provided by Factory to accomplish this is registration. Going into the dependency system and registering a new type, typically a mock or stub or spy, in order for that type to be injected into the code under test.","type":"text"}]},{"type":"codeListing","code":["Container.shared.accountLoading.register { MockNoAccounts() }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"But Factory has other enhancements designed to make unit testing and user interface testing simpler and easier.","type":"text"}]},{"inlineContent":[{"text":"Some, like ","type":"text"},{"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts","isActive":true,"type":"reference"},{"type":"text","text":" you may have already seen and used. Others, like pushing\/popping container state, resetting, and so on, are discussed below."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before we look at them, it’s important to first understand Xcode’s test process and environment, and consider what that means when writing your own unit tests using Factory."}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Jump to the end for information on using Factory with Swift Testing in Xcode 16."}],"type":"emphasis"}]},{"anchor":"The-Unit-Test-Environment","level":2,"text":"The Unit Test Environment","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"When you run a unit test, Xcode is launching and running your app in order to provide a relevant context for your test code.","type":"text"}]},{"inlineContent":[{"type":"text","text":"This means that application main ran, that the application delegate’s "},{"code":"didFinishLaunchingWithOptions","type":"codeVoice"},{"type":"text","text":" function ran, and all the code needed to get to your first screen ran. When your app reaches a state where RunLoop.main starts idling and waiting for user input, "},{"inlineContent":[{"text":"then","type":"text"}],"type":"emphasis"},{"type":"text","text":" XCTest will start constructing test classes and running test cases."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of which means that a LOT of code has already run before your first test has even fired."}]},{"inlineContent":[{"inlineContent":[{"text":"Including dependency injection code.","type":"text"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"So when writing unit tests we need to keep in mind what our initial runtime application environment looks like, what Factory registrations may have already have occurred, and in particular, if any of those registrations were scoped and cached.","type":"text"}]},{"inlineContent":[{"text":"This is specially true when dealing with ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"singletons"}]},{"text":". But again, let’s save that topic for a bit later.","type":"text"}],"type":"paragraph"},{"anchor":"Changing-Not-Rebuilding","text":"Changing, Not Rebuilding","type":"heading","level":2},{"inlineContent":[{"text":"So our environment exists, running and awaiting our first test. All of our original runtime dependency injection extensions and registrations are also out there, ready to be resolved and injected when needed.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"And that’s great. A cryptographic hashing dependency can be used in production and in test with no repercussions. We don’t need to change a thing. And in fact, the more working code we can test in its shipping state, the better.","type":"text"}]},{"inlineContent":[{"type":"text","text":"That said, other services like analytics might want to be swapped out during testing. Don’t want to feed the system all of your dummy test data. Again, "},{"isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts","type":"reference"},{"type":"text","text":" can help with that."}],"type":"paragraph"},{"inlineContent":[{"text":"But we’re here to test, and one thing we probably ","type":"text"},{"inlineContent":[{"text":"do","type":"text"}],"type":"emphasis"},{"type":"text","text":" care about is the code is talks to our APIs and other services. Those are the classes and services that we’re probably going to want to mock and reregister so we can test our view models and business logic against stable test data."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Again, Factory makes that easy.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func testNoAccounts() async {","    \/\/ register a mock","    Container.shared.accountLoading.register { MockNoAccounts() }","    \/\/ instantiate the model that uses the mock","    let model = Container.shared.accountsViewModel()","    \/\/ and test...","    await model.load()","    XCTAssertTrue(model.isLoaded)","    XCTAssertTrue(model.isEmpty)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or we can write a test against unstable test data…"}]},{"type":"codeListing","code":["func testNoAccounts() async {","    \/\/ register a mock","    Container.shared.accountLoading.register { MockAccountError(404) }","    \/\/ instantiate the model that uses the mock","    let model = Container.shared.accountsViewModel()","    \/\/ and test...","    await model.load()","    XCTAssertFalse(model.isLoaded)","    XCTAssertTrue(model.isError)","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Only if we’re running a lot of tests like this then we’re going to making a lot of changes to the dependency injection environment. And that’s problematic."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We need to make sure that a change made in one test doesn’t affect a later test that relied on the "},{"inlineContent":[{"text":"original","type":"text"}],"type":"emphasis"},{"type":"text","text":" object that demonstrated a "},{"inlineContent":[{"type":"text","text":"different"}],"type":"emphasis"},{"type":"text","text":" behavior. Or setting up circumstances where randomizing tests can cause the same thing to occur."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sound confusing? It is. Try tracking it down in actual code."}]},{"inlineContent":[{"text":"How to solve it? Well, the best solution to that sort of problem is to avoid it in the first place.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Fortunately, Factory can help with that."}]},{"level":2,"anchor":"Pushing-and-Popping-State","text":"Pushing and Popping State","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your unit test setUp function you can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"push"}]},{"type":"text","text":" the current state of the registration system and then register and test anything you want."}]},{"inlineContent":[{"type":"text","text":"Then in teardown you can "},{"type":"emphasis","inlineContent":[{"text":"pop","type":"text"}]},{"text":" the stack, eliminating all of your changes and restoring the container to its original state before the push.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This lets each set of tests start from the same initial state, regardless of what any prior test had changed.","type":"text"}]},{"inlineContent":[{"text":"The following example assumes we’re using the shared container.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        Container.shared.manager.push()","        Container.shared.setupMocks()","    }","    ","    override func tearDown() {","        Container.shared.manager.pop()","    }","    ","    func testNoAccounts() async {","        Container.shared.accountLoading.register { MockNoAccounts() }","        let model = Container.shared.accountsViewModel()","        await model.load()","        XCTAssertTrue(model.isLoaded)","        XCTAssertTrue(model.isEmpty)","    }","","    func testError() async {","        Container.shared.accountLoading.register { MockAccountError(404) }","        let model = Container.shared.accountsViewModel()","        await model.load()","        XCTAssertTrue(model.isError)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s pretty much it. Our "},{"code":"AccountsViewModel","type":"codeVoice"},{"text":" depended on an ","type":"text"},{"type":"codeVoice","code":"AccountsLoading"},{"text":" service.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Change the service provided and we change the "},{"inlineContent":[{"text":"data","type":"text"}],"type":"emphasis"},{"text":" provided. Change the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"data"}]},{"text":" provided and we change our view model’s behavior.","type":"text"}]},{"inlineContent":[{"text":"And then we test the results to see if everything matches up with our expectations.","type":"text"}],"type":"paragraph"},{"text":"Diving Deeper","level":2,"type":"heading","anchor":"Diving-Deeper"},{"type":"paragraph","inlineContent":[{"text":"Note that the above is just one way of doing things. If, for example, our ","type":"text"},{"code":"AccountLoader","type":"codeVoice"},{"text":" service depended on a custom network layer, we could reach further down the stack.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func testNoAccounts() async throws {","    let json = #\"{ \"accounts\": [] }\"#","    Container.shared.networking.register { MockJSON(json) }","    let model = Container.shared.accountsViewModel()","    \/\/ as before","}"]},{"inlineContent":[{"text":"We create the ","type":"text"},{"type":"codeVoice","code":"AccountsViewModel"},{"type":"text","text":", the view model injects the "},{"code":"AccountLoading","type":"codeVoice"},{"type":"text","text":" service, and that service injects our mock network service."}],"type":"paragraph"},{"inlineContent":[{"text":"Same for our error code.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func testNoAccounts() async throws {","    Container.shared.networking.register { MockError(404) }","    let model = Container.shared.accountsViewModel()","    \/\/ as before","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Layering your code in such a fashion can dramatically reduce the number of mocks and other objects you need to create and mange. You don’t just change the view model’s dependencies. You change the dependencies the dependencies depend on."}]},{"type":"paragraph","inlineContent":[{"text":"Factory makes reaching deep into a dependency tree and adjusting behavior simple and easy.","type":"text"}]},{"inlineContent":[{"text":"It can even help you see what’s ","type":"text"},{"inlineContent":[{"type":"text","text":"inside"}],"type":"emphasis"},{"text":" that dependency tree. See ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging"},{"text":" for more information.","type":"text"}],"type":"paragraph"},{"type":"heading","anchor":"Rebuilding-The-Container","text":"Rebuilding The Container","level":2},{"inlineContent":[{"text":"In your unit test setUp function you can also just reset the container and start over from scratch. No teardown needed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["final class FactoryCoreTests: XCTestCase {","","    override func setUp() {","        Container.shared.reset()","        Container.shared.setupMocks()","    }","    ","    func testNoAccounts() throws {","        ...","    }","}"]},{"inlineContent":[{"type":"text","text":"Note that this is pretty safe to do in the majority of cases. Your application has already launched, obtained what it needed, and is now idling."}],"type":"paragraph"},{"level":2,"type":"heading","text":"Passed Containers","anchor":"Passed-Containers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also pass the container into the view model itself."}]},{"type":"codeListing","code":["final class FactoryCoreTests: XCTestCase {","","    var container: Container!","","    override func setUp() {","        container = Container()","        container.setupMocks()","    }","    ","    func testSomething() throws {","        container.myServiceType.register(factory: { MockService() })","        let model = MyViewModel(container: container)","        model.load()","        XCTAssertTrue(model.isLoaded)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This does, of course, assume that you structured your app appropriately."}]},{"type":"heading","text":"Common Setup","anchor":"Common-Setup","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"As shown in the earlier examples, if we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier."}]},{"type":"codeListing","syntax":"swift","code":["extension Container {","    func setupMocks() {","        myService.register { MockServiceN(4) }","        sharedService.register { MockService2() }","    }","}"]},{"type":"heading","text":"Testing Singletons","level":2,"anchor":"Testing-Singletons"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s talk singletons. The singleton scope cache is global, meaning that it’s "},{"type":"emphasis","inlineContent":[{"text":"not","type":"text"}]},{"text":" managed by any specific container.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That being the case, neither the push\/pull mechanism or the container rebuilding mechanisms described above will clear any cached singleton instances."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Singletons are, after all, expected to be singletons."}]},{"type":"paragraph","inlineContent":[{"text":"So what to do about it? Well, if needed we can reset ","type":"text"},{"inlineContent":[{"text":"every","type":"text"}],"type":"emphasis"},{"type":"text","text":" cached singleton with just a single method call. Just call reset on that particular scope."}]},{"syntax":"swift","code":["Scope.singleton.reset()"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Or you can reset a specific singleton by reaching out to its factory.","type":"text"}]},{"code":["\/\/ reset everything for that factory","Container.shared.someSingletonFactory.reset()","\/\/ reset just the scope cache","Container.shared.someSingletonFactory.reset(options: .scope)","\/\/ or simply register a new instance","Container.shared.someSingletonFactory.register { MyNewMock() }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"On that last point. Doing a registration change on a factory usually clears it’s associated scope automatically. The assumption, of course, being that if you register something you expect it to be used."}]},{"inlineContent":[{"text":"This also applies to singletons ","type":"text"},{"inlineContent":[{"type":"text","text":"unless you’re inside of a autoRegister block."}],"type":"emphasis"},{"type":"text","text":" AutoRegistration can happen on every container creation, and automatically clearing a registered singleton each and every time that occurs kind of defeats the idea of multiple containers on one hand and singletons on the other."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So all that said, we can deal with them. But as a general rule, singletons can complicate your life, your code, and your tests, and as such they should be avoided and only be used when there’s an overriding need for there to be one and only one instance of an object."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Got that, Highlander?"}]},{"text":"Xcode UITesting","level":2,"anchor":"Xcode-UITesting","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"UITesting can be more challenging, in that we’re now to dealing with an active, running application. We have our existing tools, of course, but the issue is often complicated by the fact that we may want to change the application’s behavior "},{"type":"emphasis","inlineContent":[{"type":"text","text":"before"}]},{"type":"text","text":" it gets to RunLoop.main and starts idling."}]},{"type":"paragraph","inlineContent":[{"text":"How?","type":"text"}]},{"inlineContent":[{"text":"One solution is passed parameters.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The test case is fairly straightforward."}],"type":"paragraph"},{"syntax":"swift","code":["import XCTest","","final class FactoryDemoUITests: XCTestCase {","    func testExample() throws {","        let app = XCUIApplication()","        app.launchArguments.append(\"mock1\") \/\/ passed parameter","        app.launch()","","        let welcome = app.staticTexts[\"Mock Number 1! for Michael\"]","        XCTAssert(welcome.exists)","    }","}   "],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"And then in our application we use Factory’s auto registration feature to check the launch arguments to see what registrations we might want to change.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["import Foundation","import Factory","","extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        if ProcessInfo().arguments.contains(\"mock1\") {","            myServiceType.register { MockServiceN(1) }","        }","        #endif","    }","}"]},{"inlineContent":[{"type":"text","text":"Or you can simplify things with an "},{"code":"arg","type":"codeVoice"},{"type":"text","text":" context that accomplishes the same thing."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Factory","","extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myServiceType.onArg(\"mock1\") { MockServiceN(1) }","        #endif","    }","}"]},{"inlineContent":[{"text":"There are many contexts for testing, previews, and even UITesting. See ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},{"type":"text","text":" for more."}],"type":"paragraph"},{"inlineContent":[{"text":"Obviously, one can add as many different test cases and registrations as needed.","type":"text"}],"type":"paragraph"},{"anchor":"Xcode-16-and-Swift-Testing","type":"heading","level":2,"text":"Xcode 16 and Swift Testing"},{"type":"paragraph","inlineContent":[{"text":"So can we use Factory with Swift Testing in Xcode 16?","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As usual, the answer to that is complicated."}]},{"inlineContent":[{"text":"If you access Container.shared or use one of the @injected property wrappers that depend on Container.shared, then your tests need to be serialized.","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["import Testing","","@Suite(.serialized) struct AppTests {","  @Test(arguments: Parameters.allCases) func testA(parameter: Parameters) {","    \/\/ This function will be invoked serially, once per parameter, because the","    \/\/ containing suite has the .serialized trait.","    Container.shared.someService.register { MockService(parameter: parameter) }","    let service = Container.shared.someService()","    #expect(service.parameter == parameter)","  }","","","  @Test func testB() async throws {","    \/\/ This function will not run while testA(parameter:) is running. One test","    \/\/ must end before the other will start.","    Container.shared.someService.register { ErrorService() }","    let service = Container.shared.someService()","    #expect(service.error == \"Oops\")","  }","}"],"syntax":"swift"},{"inlineContent":[{"text":"The two tests above both register different values for ","type":"text"},{"code":"someService","type":"codeVoice"},{"type":"text","text":" and as such could suffer from race conditions should those tests be run in parallel."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which results in tests failing randomly."}]},{"type":"heading","level":2,"text":"Swift Testing and Container Injection","anchor":"Swift-Testing-and-Container-Injection"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you inject a specific container instance into your view models or services, then you can build and inject a separate container for each set of tests so that parallel testing works."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel {","    let service2: MyServiceType","    init(container: Container) {","        service2 = container.service()","    }","}","","@Suite struct AppTests {","  @Test(arguments: Parameters.allCases) func testA(parameter: Parameters) {","    let container = Container()","    container.someService.register { MockService(parameter: parameter) }","    let model = ContentViewModel(container: container)","    #expect(model.parameter == parameter)","  }","","","  @Test func testB() async throws {","    let container = Container()","    container.someService.register { ErrorService() }","    let model = ContentViewModel(container: container)","    #expect(model.error == \"Oops\")","  }","}"]},{"inlineContent":[{"type":"text","text":"Here, every instance of ContentViewModel gets its own dedicated container and as such parallel testing will work as expected."}],"type":"paragraph"},{"type":"heading","level":2,"text":"Swift Testing and Global Shared and Static Values","anchor":"Swift-Testing-and-Global-Shared-and-Static-Values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This issue isn’t specific to Factor or Resolver, and in fact impacts other scenarios like using a "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.swiftwithvincent.com\/blog\/how-to-mock-any-network-call-with-urlprotocol"},{"type":"text","text":" on URLSession.shared, or testing any code that depends on a global or statically shared variable."}]},{"type":"paragraph","inlineContent":[{"text":"Setting up a URLProtocol result in testA and another in testB could cause race conditions when tests aren’t seeing the results that they’re expecting.","type":"text"}]}],"kind":"content"}],"metadata":{"modules":[{"name":"Factory"}],"role":"article","roleHeading":"Article","title":"Testing"},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"references":{"doc://Factory/documentation/Factory/Debugging":{"url":"\/documentation\/factory\/debugging","role":"article","title":"Debugging","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"kind":"article","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging"},"doc://Factory/documentation/Factory":{"role":"collection","type":"topic","abstract":[{"text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"identifier":"doc:\/\/Factory\/documentation\/Factory","url":"\/documentation\/factory","title":"Factory","kind":"symbol"},"doc://Factory/documentation/Factory/Previews":{"type":"topic","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"kind":"article","role":"article","url":"\/documentation\/factory\/previews","title":"SwiftUI Previews","identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews"},"https://www.swiftwithvincent.com/blog/how-to-mock-any-network-call-with-urlprotocol":{"type":"link","titleInlineContent":[{"type":"text","text":"URLProtocol"}],"url":"https:\/\/www.swiftwithvincent.com\/blog\/how-to-mock-any-network-call-with-urlprotocol","title":"URLProtocol","identifier":"https:\/\/www.swiftwithvincent.com\/blog\/how-to-mock-any-network-call-with-urlprotocol"},"doc://Factory/documentation/Factory/Contexts":{"kind":"article","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts","url":"\/documentation\/factory\/contexts","title":"Contexts","role":"article","abstract":[{"text":"Changing injection results under special circumstances.","type":"text"}]},"doc://Factory/documentation/Factory/Chains":{"url":"\/documentation\/factory\/chains","role":"article","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"title":"Circular Dependency Chains","kind":"article","type":"topic","identifier":"doc:\/\/Factory\/documentation\/Factory\/Chains"}}}